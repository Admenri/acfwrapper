// Copyright (c) 2025 Admenri. All rights reserved.
// ---------------------------------------------------------------------------
//
// This file was generated by the ACF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
// $hash=8248bc09585941aff4ecf6b6307f7f19fbeb4bf7$
//

#ifndef ACF_INCLUDE_CAPI_ACF_PARSER_CAPI_H_
#define ACF_INCLUDE_CAPI_ACF_PARSER_CAPI_H_
#pragma once

#include "include/capi/acf_base_capi.h"

#ifdef __cplusplus
extern "C" {
#endif

///
/// Encodes |data| as a base64 string.
///
// The resulting string must be freed by calling acf_string_userfree_free().
ACF_EXPORT acf_string_userfree_t acf_base64encode(const void* data,
                                                  size_t data_size);

///
/// Decodes the base64 encoded string |data|. The returned value will be NULL if
/// the decoding fails.
///
ACF_EXPORT struct _acf_binary_value_t* acf_base64decode(
    const acf_string_t* data);

///
/// Escapes characters in |text| which are unsuitable for use as a query
/// parameter value. Everything except alphanumerics and -_.!~*'() will be
/// converted to "%XX". If |use_plus| is true (1) spaces will change to "+". The
/// result is basically the same as encodeURIComponent in Javacript.
///
// The resulting string must be freed by calling acf_string_userfree_free().
ACF_EXPORT acf_string_userfree_t acf_uriencode(const acf_string_t* text,
                                               int use_plus);

///
/// Unescapes |text| and returns the result. Unescaping consists of looking for
/// the exact pattern "%XX" where each X is a hex digit and converting to the
/// character with the numerical value of those digits (e.g. "i%20=%203%3b"
/// unescapes to "i = 3;"). If |convert_to_utf8| is true (1) this function will
/// attempt to interpret the initial decoded result as UTF-8. If the result is
/// convertable into UTF-8 it will be returned as converted. Otherwise the
/// initial decoded result will be returned.  The |unescape_rule| parameter
/// supports further customization the decoding process.
///
// The resulting string must be freed by calling acf_string_userfree_free().
ACF_EXPORT acf_string_userfree_t
acf_uridecode(const acf_string_t* text,
              int convert_to_utf8,
              acf_uri_unescape_rule_t unescape_rule);

///
/// Parses the specified |json_string| and returns a dictionary or list
/// representation. If JSON parsing fails this function returns NULL.
///
ACF_EXPORT struct _acf_value_t* acf_parse_json(
    const acf_string_t* json_string,
    acf_json_parser_options_t options);

///
/// Parses the specified UTF8-encoded |json| buffer of size |json_size| and
/// returns a dictionary or list representation. If JSON parsing fails this
/// function returns NULL.
///
ACF_EXPORT struct _acf_value_t* acf_parse_json_buffer(
    const void* json,
    size_t json_size,
    acf_json_parser_options_t options);

///
/// Parses the specified |json_string| and returns a dictionary or list
/// representation. If JSON parsing fails this function returns NULL and
/// populates |error_msg_out| with a formatted error message.
///
ACF_EXPORT struct _acf_value_t* acf_parse_jsonand_return_error(
    const acf_string_t* json_string,
    acf_json_parser_options_t options,
    acf_string_t* error_msg_out);

///
/// Generates a JSON string from the specified root |node| which should be a
/// dictionary or list value. Returns an NULL string on failure. This function
/// requires exclusive access to |node| including any underlying data.
///
// The resulting string must be freed by calling acf_string_userfree_free().
ACF_EXPORT acf_string_userfree_t
acf_write_json(struct _acf_value_t* node, acf_json_writer_options_t options);

#ifdef __cplusplus
}
#endif

#endif  // ACF_INCLUDE_CAPI_ACF_PARSER_CAPI_H_
