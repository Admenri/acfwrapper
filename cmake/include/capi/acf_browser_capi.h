// Copyright (c) 2025 Admenri. All rights reserved.
// ---------------------------------------------------------------------------
//
// This file was generated by the ACF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
// $hash=b677cf222e08ab0ecc86725950ecb2c4758676a0$
//

#ifndef ACF_INCLUDE_CAPI_ACF_BROWSER_CAPI_H_
#define ACF_INCLUDE_CAPI_ACF_BROWSER_CAPI_H_
#pragma once

#include "include/capi/acf_callback_capi.h"
#include "include/capi/acf_context_menu_capi.h"
#include "include/capi/acf_registration_capi.h"
#include "include/capi/acf_values_capi.h"
#include "include/capi/acf_websocket_capi.h"
#include "include/internal/acf_enums.h"
#include "include/internal/acf_scoped_refptr.h"
#include "include/internal/acf_string.h"
#include "include/internal/acf_string_list.h"
#include "include/internal/acf_types.h"
#include "include/internal/acf_types_wrappers.h"

#ifdef __cplusplus
extern "C" {
#endif

struct _acf_browser_t;
struct _acf_context_menu_callback_t;
struct _acf_dev_tools_message_observer_t;
struct _acf_dictionary_value_t;
struct _acf_environment_t;
struct _acf_file_dialog_callback_t;
struct _acf_frame_t;
struct _acf_function_factory_t;
struct _acf_java_script_dialog_callback_t;
struct _acf_new_window_delegate_t;
struct _acf_profile_t;
struct _acf_registration_t;
struct _acf_web_message_factory_t;
struct _acf_web_socket_client_handler_t;

///
/// New Window delegate, set a new browser to host target page. Request will be
/// handled while object was destroyed without handled.
///
typedef struct _acf_new_window_delegate_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Set a browser to handle the new window new browser's profile must suit the
  /// host browser's profile, otherwise return false (0).
  ///
  int(ACF_CALLBACK* set_new_browser)(struct _acf_new_window_delegate_t* self,
                                     struct _acf_browser_t* browser);

  ///
  /// Get target url
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_target_url)(
      struct _acf_new_window_delegate_t* self);

  ///
  /// Put if user has been handled the request. This function will send the
  /// final request to browser. Must called ResumeNewWindowLoading() after the
  /// calling.
  ///
  void(ACF_CALLBACK* handle_request)(struct _acf_new_window_delegate_t* self,
                                     int handled,
                                     int suspend_loading);
} acf_new_window_delegate_t;

///
/// Context menu callback
///
typedef struct _acf_context_menu_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Continue show menu
  ///
  void(ACF_CALLBACK* cont)(struct _acf_context_menu_callback_t* self,
                           int suppress);
} acf_context_menu_callback_t;

///
/// Javascript dialogs callback
///
typedef struct _acf_java_script_dialog_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Continue dialogs
  ///
  void(ACF_CALLBACK* cont)(struct _acf_java_script_dialog_callback_t* self,
                           int success,
                           const acf_string_t* user_input);
} acf_java_script_dialog_callback_t;

///
/// Callback structure for asynchronous continuation of file dialog requests.
///
typedef struct _acf_file_dialog_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Continue the file selection. |file_paths| should be a single value or a
  /// list of values depending on the dialog mode. An NULL |file_paths| value is
  /// treated the same as calling cancel().
  ///
  void(ACF_CALLBACK* cont)(struct _acf_file_dialog_callback_t* self,
                           int use_default,
                           acf_string_list_t file_paths,
                           const acf_string_t* base_path);

  ///
  /// Cancel the file selection.
  ///
  void(ACF_CALLBACK* cancel)(struct _acf_file_dialog_callback_t* self);
} acf_file_dialog_callback_t;

///
/// Network auth callback delegate
///
typedef struct _acf_login_delegate_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Continue with username and password.
  ///
  void(ACF_CALLBACK* cont)(struct _acf_login_delegate_t* self,
                           const acf_string_t* user_name,
                           const acf_string_t* password);

  ///
  /// Cancel auth request. (Default)
  ///
  void(ACF_CALLBACK* cancel)(struct _acf_login_delegate_t* self);
} acf_login_delegate_t;

///
/// Callback structure used for asynchronous continuation of permission prompts.
///
typedef struct _acf_permission_prompt_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Complete the permissions request with the specified |result|.
  ///
  void(ACF_CALLBACK* cont)(struct _acf_permission_prompt_callback_t* self,
                           acf_permission_request_result_t result);
} acf_permission_prompt_callback_t;

///
/// Browser event list handler. All event in this handler will be called on
/// event thread.
///
typedef struct _acf_browser_handler_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Called when browser has been initialized from environment.
  ///
  void(ACF_CALLBACK* on_browser_created)(struct _acf_browser_handler_t* self,
                                         struct _acf_browser_t* browser);

  ///
  /// The browser will open a new Browser as NewWindow
  ///
  void(ACF_CALLBACK* on_new_window_request)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      acf_new_window_source_t source,
      acf_new_window_disposition_t disposition,
      const acf_popup_features_t* popup_features,
      int user_gesture,
      struct _acf_new_window_delegate_t* delegate);

  ///
  /// When the browser was sured to be destroyed, the browser will call this
  /// event.
  ///
  void(ACF_CALLBACK* on_browser_destroyed)(struct _acf_browser_handler_t* self,
                                           struct _acf_browser_t* browser);

  ///
  /// Loading state changed (async)
  ///
  void(ACF_CALLBACK* on_loading_state_changed)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      int show_loading_ui);

  ///
  /// Navigation state changed (title url icon historical)
  ///
  void(ACF_CALLBACK* on_navigation_state_changed)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      acf_navigation_types_t flags);

  ///
  /// Activate browser event.
  ///
  void(ACF_CALLBACK* on_activate_contents)(struct _acf_browser_handler_t* self,
                                           struct _acf_browser_t* browser);

  ///
  /// Browser fullscreen state changed.
  ///
  void(ACF_CALLBACK* on_fullscreen_state_changed)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      int fullscreen);

  ///
  /// Context menu request, return true (1) for blocking menu popup
  ///
  void(ACF_CALLBACK* on_context_menu_request)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      struct _acf_context_menu_params_t* menu_params,
      struct _acf_context_menu_model_t* menu_model,
      struct _acf_context_menu_callback_t* callback);

  ///
  /// Context menu request to execute |command_id| associate item command.
  ///
  void(ACF_CALLBACK* on_context_menu_execute)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      struct _acf_context_menu_params_t* menu_params,
      int command_id,
      int event_flags);

  ///
  /// Called to run a file chooser dialog. |mode| represents the type of dialog
  /// to display. |title| to the title to be used for the dialog and may be NULL
  /// to show the default title ("Open" or "Save" depending on the mode).
  /// |default_file_path| is the path with optional directory and/or file name
  /// component that should be initially selected in the dialog.
  /// |accept_filters| are used to restrict the selectable file types and may
  /// any combination of (a) valid lower-cased MIME types (e.g. "text/*" or
  /// "image/*"), (b) individual file extensions (e.g. ".txt" or ".png"), or (c)
  /// combined description and file extension delimited using "|" and ";" (e.g.
  /// "Image Types|.png;.gif;.jpg"). To display a custom dialog return true (1)
  /// and execute |callback| either inline or at a later time. To display the
  /// default dialog return false (0).
  ///
  void(ACF_CALLBACK* on_file_dialog)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      acf_file_dialog_mode_t mode,
      const acf_string_t* title,
      const acf_string_t* default_file_path,
      acf_string_list_t accept_filters,
      struct _acf_file_dialog_callback_t* callback);

  ///
  /// Displays a JavaScript dialog.
  ///
  void(ACF_CALLBACK* on_java_script_dialog)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      struct _acf_frame_t* frame,
      acf_jsdialog_type_t dialog_type,
      const acf_string_t* message_text,
      const acf_string_t* default_prompt_text,
      struct _acf_java_script_dialog_callback_t* callback);

  ///
  /// Displays a dialog asking the user if they want to leave a page.
  ///
  void(ACF_CALLBACK* on_before_unload_dialog)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      struct _acf_frame_t* frame,
      int is_reload,
      struct _acf_java_script_dialog_callback_t* callback);

  ///
  /// Accepts or dismisses the active JavaScript dialog, which must be owned by
  /// the given |web_contents|. If |prompt_override| is not null, the prompt
  /// text of the dialog should be set before accepting.
  ///
  void(ACF_CALLBACK* on_handle_java_script_dialog)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      int accept,
      const acf_string_t* prompt_override);

  ///
  /// Cancels all active and pending dialogs for the given WebContents. If
  /// |reset_state| is true (1), resets any saved state tied to |web_contents|.
  ///
  void(ACF_CALLBACK* on_cancel_java_script_dialogs)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      int reset_state);

  ///
  /// network need auth request (Called when disable default auth login dialog.)
  ///
  void(ACF_CALLBACK* on_auth_login_request)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      int is_proxy,
      const acf_string_t* host,
      const acf_string_t* url,
      const acf_string_t* scheme,
      const acf_string_t* realm,
      const acf_string_t* challenge,
      int is_main_frame,
      struct _acf_login_delegate_t* delegate);

  ///
  /// Called when a page should show a permission prompt. |prompt_id| uniquely
  /// identifies the prompt. |requesting_origin| is the URL origin requesting
  /// permission. |requested_permissions| is a combination of values from
  /// acf_permission_request_types_t that represent the requested permissions.
  /// Return true (1) and call acf_permission_prompt_callback_t::Continue either
  /// in this function or at a later time to continue or cancel the request.
  /// Return false (0) to proceed with default handling. With the Chrome
  /// runtime, default handling will display the permission prompt UI. With the
  /// Alloy runtime, default handling is ACF_PERMISSION_RESULT_IGNORE.
  ///
  void(ACF_CALLBACK* on_show_permission_prompt)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      uint64 prompt_id,
      const acf_string_t* requesting_origin,
      uint32 requested_permissions,
      struct _acf_permission_prompt_callback_t* callback);

  ///
  /// Called when a permission prompt handled via OnShowPermissionPrompt is
  /// dismissed. |prompt_id| will match the value that was passed to
  /// OnShowPermissionPrompt. |result| will be the value passed to
  /// acf_permission_prompt_callback_t::Continue or ACF_PERMISSION_RESULT_IGNORE
  /// if the dialog was dismissed for other reasons such as navigation, browser
  /// closure, etc. This function will not be called if OnShowPermissionPrompt
  /// returned false (0) for |prompt_id|.
  ///
  void(ACF_CALLBACK* on_dismiss_permission_prompt)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      uint64 prompt_id,
      acf_permission_request_result_t result);

  ///
  /// Async running on browser navigation request, default: Continue(false (0)).
  /// The request object is readonly without any post data and cookie data.
  ///
  void(ACF_CALLBACK* on_before_navigation)(struct _acf_browser_handler_t* self,
                                           struct _acf_browser_t* browser,
                                           struct _acf_frame_t* frame,
                                           const acf_string_t* url,
                                           const acf_string_t* referrer,
                                           int user_gesture,
                                           int is_redirect,
                                           struct _acf_callback_t* callback);

  ///
  /// Called to display a console message.
  ///
  void(ACF_CALLBACK* on_console_message)(struct _acf_browser_handler_t* self,
                                         struct _acf_browser_t* browser,
                                         int level,
                                         const acf_string_t* message,
                                         const acf_string_t* source,
                                         int line,
                                         const acf_string_t* trace);

  ///
  /// Called when the overall page loading progress has changed. |progress|
  /// ranges from 0.0 to 1.0.
  ///
  void(ACF_CALLBACK* on_loading_progress_change)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      double progress);

  ///
  /// Called when audible state was changed.
  ///
  void(ACF_CALLBACK* on_audio_state_change)(struct _acf_browser_handler_t* self,
                                            struct _acf_browser_t* browser,
                                            int audible);

  ///
  /// Called when renderer request to create websocket connection. Allowed user
  /// to hook websocket connection. |target_url| can be modified in the event.
  ///
  struct _acf_web_socket_client_handler_t*(ACF_CALLBACK* create_web_socket)(
      struct _acf_browser_handler_t* self,
      struct _acf_browser_t* browser,
      acf_string_t* target_url);

  ///
  /// These three functions correspond to the points in time when any document
  /// in the frame tree starts loading for the first time (initiates outgoing
  /// requests), when incoming data subsequently starts arriving, and when the
  /// whole frame tree finishes loading. Notes: - There is no guarantee that
  /// calls to DidStartLoading/DidStopLoading are
  ///   interleaved (e.g. there can be 2 calls to DidStartLoading in a row).
  /// - These functions are different and unrelated from DidFinishLoad, which
  ///   is a notification about a specific document instead of the whole frame
  ///   tree, and uses a slightly different trigger to signify that the load had
  ///   finished.
  ///
  void(ACF_CALLBACK* did_start_loading)(struct _acf_browser_handler_t* self,
                                        struct _acf_browser_t* browser);

  ///
  /// See "DidStartLoading" handler description.
  ///
  void(ACF_CALLBACK* did_stop_loading)(struct _acf_browser_handler_t* self,
                                       struct _acf_browser_t* browser);

  ///
  /// The page has made some progress loading. |progress| is a value between 0.0
  /// (nothing loaded) to 1.0 (page fully loaded).
  ///
  void(ACF_CALLBACK* load_progress_changed)(struct _acf_browser_handler_t* self,
                                            struct _acf_browser_t* browser,
                                            double progress);
} acf_browser_handler_t;

///
/// ACF's browser object host, in fact a browser was a window in chromium with
/// tabs control.
///
typedef struct _acf_browser_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Is same object.
  ///
  int(ACF_CALLBACK* is_same)(struct _acf_browser_t* self,
                             struct _acf_browser_t* that);

  ///
  /// Get browser create's sign.
  ///
  struct _acf_dictionary_value_t*(ACF_CALLBACK* get_extra_info)(
      struct _acf_browser_t* self);

  ///
  /// Get parent environment.
  ///
  struct _acf_environment_t*(ACF_CALLBACK* get_environment)(
      struct _acf_browser_t* self);

  ///
  /// Close browser, it will call browser close event. (or unlaod dialog)
  ///
  void(ACF_CALLBACK* close)(struct _acf_browser_t* self, int force);

  ///
  /// Resume new window loading
  ///
  void(ACF_CALLBACK* resume_loading_browser)(struct _acf_browser_t* self);

  ///
  /// Get browser window handle.
  ///
  acf_window_handle_t(ACF_CALLBACK* get_window_handle)(
      struct _acf_browser_t* self);

  ///
  /// Get browser delegate invalid status.
  ///
  int(ACF_CALLBACK* is_valid)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: can go back
  ///
  int(ACF_CALLBACK* can_go_back)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: can go forward
  ///
  int(ACF_CALLBACK* can_go_forward)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: go back
  ///
  void(ACF_CALLBACK* go_back)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: go forward
  ///
  void(ACF_CALLBACK* go_forward)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: reload
  ///
  void(ACF_CALLBACK* reload)(struct _acf_browser_t* self, int ignore_cache);

  ///
  /// Browser navigation entry controller: stop loading
  ///
  void(ACF_CALLBACK* stop)(struct _acf_browser_t* self);

  ///
  /// Browser navigation entry controller: loading
  ///
  int(ACF_CALLBACK* is_loading)(struct _acf_browser_t* self);

  ///
  /// Navigate to target url (Main frame).
  ///
  void(ACF_CALLBACK* load_url)(struct _acf_browser_t* self,
                               const acf_string_t* url,
                               const acf_string_t* referrer_url,
                               acf_referrer_policy_t referrer_policy,
                               acf_transition_type_t transition_type,
                               const acf_string_t* extra_header);

  ///
  /// Get current url
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_url)(struct _acf_browser_t* self);

  ///
  /// Get title
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_title)(struct _acf_browser_t* self);

  ///
  /// Get favicon url
  ///
  // The resulting string must be freed by calling acf_string_userfree_free().
  acf_string_userfree_t(ACF_CALLBACK* get_favicon)(struct _acf_browser_t* self);

  ///
  /// Focus to native widget
  ///
  void(ACF_CALLBACK* focus)(struct _acf_browser_t* self);

  ///
  /// Set/Get window visible
  ///
  void(ACF_CALLBACK* set_visible)(struct _acf_browser_t* self, int visible);

  ///
  /// Get visibility
  ///
  int(ACF_CALLBACK* get_visible)(struct _acf_browser_t* self);

  ///
  /// Get profile object, maybe null
  ///
  struct _acf_profile_t*(ACF_CALLBACK* get_profile)(
      struct _acf_browser_t* self);

  ///
  /// Returns the number of frames that currently exist.
  ///
  size_t(ACF_CALLBACK* get_frame_count)(struct _acf_browser_t* self);

  ///
  /// Returns the identifiers of all existing frames.
  ///
  void(ACF_CALLBACK* get_frame_identifiers)(struct _acf_browser_t* self,
                                            size_t* identifiersCount,
                                            int64* identifiers);

  ///
  /// Returns the names of all existing frames.
  ///
  void(ACF_CALLBACK* get_frame_names)(struct _acf_browser_t* self,
                                      acf_string_list_t names);

  ///
  /// Returns the frame with the specified identifier, or NULL if not found.
  ///
  struct _acf_frame_t*(ACF_CALLBACK* get_frame_byident)(
      struct _acf_browser_t* self,
      int64 identifier);

  ///
  /// Returns the frame with the specified name, or NULL if not found.
  ///
  struct _acf_frame_t*(ACF_CALLBACK* get_frame)(struct _acf_browser_t* self,
                                                const acf_string_t* name);

  ///
  /// Returns the main (top-level) frame for the browser.
  ///
  struct _acf_frame_t*(ACF_CALLBACK* get_main_frame)(
      struct _acf_browser_t* self);

  ///
  /// Set browser additional settings. (Dynamic)
  ///
  void(ACF_CALLBACK* set_settings)(struct _acf_browser_t* self,
                                   const acf_browser_settings_t* settings);

  ///
  /// Set audio mute state.
  ///
  void(ACF_CALLBACK* set_audio_muted)(struct _acf_browser_t* self, int muted);

  ///
  /// Get audio mute state.
  ///
  int(ACF_CALLBACK* is_audio_muted)(struct _acf_browser_t* self);

  ///
  /// Toggle devtools.
  ///
  void(ACF_CALLBACK* toggle_devtools)(struct _acf_browser_t* self);

  ///
  /// Open a browser task manager.
  ///
  void(ACF_CALLBACK* open_task_manager)(struct _acf_browser_t* self);

  ///
  /// Raise find bar.
  ///
  void(ACF_CALLBACK* raise_find_bar)(struct _acf_browser_t* self);

  ///
  /// Zoom page in current browser.
  ///
  void(ACF_CALLBACK* zoom_page)(struct _acf_browser_t* self,
                                acf_zoom_type_t zoom_type);

  ///
  /// Toggle extensions menu in current browser window.
  ///
  void(ACF_CALLBACK* toggle_extensions_menu)(struct _acf_browser_t* self);

  ///
  /// Toggle browser built-in download ui.
  ///
  void(ACF_CALLBACK* toggle_download_uifor_window)(struct _acf_browser_t* self);

  ///
  /// Toggle media router bubble for media controller.
  ///
  void(ACF_CALLBACK* toggle_media_router_bubble)(struct _acf_browser_t* self);

  ///
  /// Send a key event to the browser.
  ///
  void(ACF_CALLBACK* send_key_event)(struct _acf_browser_t* self,
                                     const acf_key_event_t* event);

  ///
  /// Send a mouse click event to the browser. The |x| and |y| coordinates are
  /// relative to the upper-left corner of the view.
  ///
  void(ACF_CALLBACK* send_mouse_click_event)(struct _acf_browser_t* self,
                                             const acf_mouse_event_t* event,
                                             acf_mouse_button_type_t type,
                                             int mouseUp,
                                             int clickCount);

  ///
  /// Send a mouse move event to the browser. The |x| and |y| coordinates are
  /// relative to the upper-left corner of the view.
  ///
  void(ACF_CALLBACK* send_mouse_move_event)(struct _acf_browser_t* self,
                                            const acf_mouse_event_t* event,
                                            int mouseLeave);

  ///
  /// Send a mouse wheel event to the browser. The |x| and |y| coordinates are
  /// relative to the upper-left corner of the view. The |deltaX| and |deltaY|
  /// values represent the movement delta in the X and Y directions
  /// respectively.
  ///
  void(ACF_CALLBACK* send_mouse_wheel_event)(struct _acf_browser_t* self,
                                             const acf_mouse_event_t* event,
                                             int deltaX,
                                             int deltaY);

  ///
  /// Add script before document created. Origins: * for all match urls
  ///
  int(ACF_CALLBACK* add_document_start_java_script)(
      struct _acf_browser_t* self,
      const acf_string_t* script,
      acf_string_list_t allow_origins);

  ///
  /// Remove script by script-id.
  ///
  void(ACF_CALLBACK* remove_document_start_java_script)(
      struct _acf_browser_t* self,
      int script_id);

  ///
  /// Create a Javascript object on renderer for web message routing.
  ///
  void(ACF_CALLBACK* add_web_message_host_factory)(
      struct _acf_browser_t* self,
      struct _acf_web_message_factory_t* factory,
      const acf_string_t* js_object_name,
      acf_string_list_t allow_origins);

  ///
  /// Remove host factory for web message.
  ///
  void(ACF_CALLBACK* remove_web_message_host_factory)(
      struct _acf_browser_t* self,
      const acf_string_t* js_object_name);

  ///
  /// Create a Javascript object on renderer for web message routing.
  ///
  void(ACF_CALLBACK* add_function_register_host_factory)(
      struct _acf_browser_t* self,
      struct _acf_function_factory_t* factory,
      const acf_string_t* js_object_name,
      const acf_string_t* function_name,
      acf_string_list_t allow_origins);

  ///
  /// Remove host factory for web message.
  ///
  void(ACF_CALLBACK* remove_function_register_host_factory)(
      struct _acf_browser_t* self,
      const acf_string_t* js_object_name);

  ///
  /// Send a function call message over the DevTools protocol. |message| must be
  /// a UTF8-encoded JSON dictionary that contains "id" (int), "function"
  /// (string) and "params" (dictionary, optional) values. See the DevTools
  /// protocol documentation at https://chromedevtools.github.io/devtools-
  /// protocol/ for details of supported functions and the expected "params"
  /// dictionary contents. |message| will be copied if necessary. This function
  /// will return true (1) if called on the UI thread and the message was
  /// successfully submitted for validation, otherwise false (0). Validation
  /// will be applied asynchronously and any messages that fail due to
  /// formatting errors or missing parameters may be discarded without
  /// notification. Prefer ExecuteDevToolsMethod if a more structured approach
  /// to message formatting is desired.
  ///
  /// Every valid function call will result in an asynchronous function result
  /// or error message that references the sent message "id". Event messages are
  /// received while notifications are enabled (for example, between function
  /// calls for "Page.enable" and "Page.disable"). All received messages will be
  /// delivered to the observer(s) registered with AddDevToolsMessageObserver.
  /// See acf_dev_tools_message_observer_t::OnDevToolsMessage documentation for
  /// details of received message contents.
  ///
  /// Usage of the SendDevToolsMessage, ExecuteDevToolsMethod and
  /// AddDevToolsMessageObserver functions does not require an active DevTools
  /// front-end or remote-debugging session. Other active DevTools sessions will
  /// continue to function independently. However, any modification of global
  /// browser state by one session may not be reflected in the UI of other
  /// sessions.
  ///
  /// Communication with the DevTools front-end (when displayed) can be logged
  /// for development purposes by passing the `--devtools-protocol-log-
  /// file=<path>` command-line flag.
  ///
  void(ACF_CALLBACK* send_dev_tools_message)(struct _acf_browser_t* self,
                                             const void* message,
                                             size_t message_size);

  ///
  /// Add an observer for DevTools protocol messages (function results and
  /// events). The observer will remain registered until the returned
  /// Registration object is destroyed. See the SendDevToolsMessage
  /// documentation for additional usage information.
  ///
  struct _acf_registration_t*(ACF_CALLBACK* add_dev_tools_message_observer)(
      struct _acf_browser_t* self,
      struct _acf_dev_tools_message_observer_t* observer);

  ///
  /// Begins a new composition or updates the existing composition. Blink has a
  /// special node (a composition node) that allows the input function to change
  /// text without affecting other DOM nodes. |text| is the optional text that
  /// will be inserted into the composition node. |underlines| is an optional
  /// set of ranges that will be underlined in the resulting text.
  /// |replacement_range| is an optional range of the existing text that will be
  /// replaced. |selection_range| is an optional range of the resulting text
  /// that will be selected after insertion or replacement. The
  /// |replacement_range| value is only used on OS X.
  ///
  /// This function may be called multiple times as the composition changes.
  /// When the client is done making changes the composition should either be
  /// canceled or completed. To cancel the composition call
  /// ImeCancelComposition. To complete the composition call either
  /// ImeCommitText or ImeFinishComposingText. Completion is usually signaled
  /// when:
  ///
  /// 1. The client receives a WM_IME_COMPOSITION message with a GCS_RESULTSTR
  ///    flag (on Windows), or;
  /// 2. The client receives a "commit" signal of GtkIMContext (on Linux), or;
  /// 3. insertText of NSTextInput is called (on Mac).
  ///
  /// This function is only used when window rendering is disabled.
  ///
  void(ACF_CALLBACK* ime_set_composition)(
      struct _acf_browser_t* self,
      const acf_string_t* text,
      size_t underlinesCount,
      acf_composition_underline_t const* underlines,
      const acf_range_t* replacement_range,
      const acf_range_t* selection_range);

  ///
  /// Completes the existing composition by optionally inserting the specified
  /// |text| into the composition node. |replacement_range| is an optional range
  /// of the existing text that will be replaced. |relative_cursor_pos| is where
  /// the cursor will be positioned relative to the current cursor position. See
  /// comments on ImeSetComposition for usage. The |replacement_range| and
  /// |relative_cursor_pos| values are only used on OS X. This function is only
  /// used when window rendering is disabled.
  ///
  void(ACF_CALLBACK* ime_commit_text)(struct _acf_browser_t* self,
                                      const acf_string_t* text,
                                      const acf_range_t* replacement_range,
                                      int relative_cursor_pos);

  ///
  /// Completes the existing composition by applying the current composition
  /// node contents. If |keep_selection| is false (0) the current selection, if
  /// any, will be discarded. See comments on ImeSetComposition for usage. This
  /// function is only used when window rendering is disabled.
  ///
  void(ACF_CALLBACK* ime_finish_composing_text)(struct _acf_browser_t* self,
                                                int keep_selection);

  ///
  /// Cancels the existing composition and discards the composition node
  /// contents without applying them. See comments on ImeSetComposition for
  /// usage. This function is only used when window rendering is disabled.
  ///
  void(ACF_CALLBACK* ime_cancel_composition)(struct _acf_browser_t* self);

  ///
  /// Capture screenshot from frame's widget view host. Return encoded png data.
  /// Handler value is acf_binary_value_t which data is the png result.
  ///
  void(ACF_CALLBACK* capture_screenshot)(
      struct _acf_browser_t* self,
      int fast_encoded,
      int from_surface,
      struct _acf_complete_value_handler_t* handler);

  ///
  /// Set browser renderer context profile info (environment features).
  ///
  void(ACF_CALLBACK* set_context_profile)(struct _acf_browser_t* self,
                                          struct _acf_value_t* context_profile);
} acf_browser_t;

#ifdef __cplusplus
}
#endif

#endif  // ACF_INCLUDE_CAPI_ACF_BROWSER_CAPI_H_
