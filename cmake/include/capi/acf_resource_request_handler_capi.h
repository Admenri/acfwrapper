// Copyright (c) 2025 Admenri. All rights reserved.
// ---------------------------------------------------------------------------
//
// This file was generated by the ACF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//
// $hash=52187ac3e8796ab024ff16beb1fd010371d70a8c$
//

#ifndef ACF_INCLUDE_CAPI_ACF_RESOURCE_REQUEST_HANDLER_CAPI_H_
#define ACF_INCLUDE_CAPI_ACF_RESOURCE_REQUEST_HANDLER_CAPI_H_
#pragma once

#include "include/capi/acf_callback_capi.h"
#include "include/capi/acf_frame_capi.h"
#include "include/capi/acf_profile_capi.h"
#include "include/capi/acf_request_capi.h"
#include "include/capi/acf_response_capi.h"
#include "include/internal/acf_scoped_refptr.h"
#include "include/internal/acf_types.h"

#ifdef __cplusplus
extern "C" {
#endif

struct _acf_callback_t;
struct _acf_frame_t;
struct _acf_resource_handler_t;
struct _acf_resource_read_callback_t;
struct _acf_resource_request_handler_t;
struct _acf_resource_skip_callback_t;
struct _acf_response_filter_t;

///
/// Implement this structure to handle events related to browser requests. The
/// functions of this structure will be called on the runner thread unless
/// otherwise indicated.
///
typedef struct _acf_resource_request_handler_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Called on the runner thread before a resource request is loaded. You can
  /// modify request object data in this event until return. Return a custom
  /// resource handler to intercept network route.
  ///
  struct _acf_resource_handler_t*(ACF_CALLBACK* on_before_resource_load)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_request_t* request);

  ///
  /// Called on the runner thread when a resource response is received. The
  /// response maybe a redirect request. You can modify request's URL and
  /// determined request's next action here. Return a filter object for modifing
  /// response body data. mode must fill with acf_response_mode_t type data.
  ///
  struct _acf_response_filter_t*(ACF_CALLBACK* on_resource_response)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_request_t* request,
      struct _acf_response_t* response,
      int* mode);

  ///
  /// Called on the runner thread when a resource load has completed. Failed
  /// request maybe sent in this event.
  ///
  void(ACF_CALLBACK* on_resource_load_complete)(
      struct _acf_resource_request_handler_t* self,
      struct _acf_request_t* request,
      acf_urlrequest_status_t status,
      int64 received_content_length);
} acf_resource_request_handler_t;

///
/// Callback for asynchronous continuation of acf_resource_handler_t::skip().
///
typedef struct _acf_resource_skip_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Callback for asynchronous continuation of skip(). If |bytes_skipped| > 0
  /// then either skip() will be called again until the requested number of
  /// bytes have been skipped or the request will proceed. If |bytes_skipped| <=
  /// 0 the request will fail with ERR_REQUEST_RANGE_NOT_SATISFIABLE.
  ///
  void(ACF_CALLBACK* cont)(struct _acf_resource_skip_callback_t* self,
                           int64 bytes_skipped);
} acf_resource_skip_callback_t;

///
/// Callback for asynchronous continuation of acf_resource_handler_t::read().
///
typedef struct _acf_resource_read_callback_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Callback for asynchronous continuation of read(). If |bytes_read| == 0 the
  /// response will be considered complete. If |bytes_read| > 0 then read() will
  /// be called again until the request is complete (based on either the result
  /// or the expected content length). If |bytes_read| < 0 then the request will
  /// fail and the |bytes_read| value will be treated as the error code.
  ///
  void(ACF_CALLBACK* cont)(struct _acf_resource_read_callback_t* self,
                           int bytes_read);
} acf_resource_read_callback_t;

///
/// Structure used to implement a custom request handler structure. The
/// functions of this structure will be called on the IO thread unless otherwise
/// indicated.
///
typedef struct _acf_resource_handler_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Retrieve response header information. If the response length is not known
  /// set |response_length| to -1 and ReadResponse() will be called until it
  /// returns false (0). If the response length is known set |response_length|
  /// to a positive value and ReadResponse() will be called until it returns
  /// false (0) or the specified number of bytes have been read. Use the
  /// |response| object to set the mime type, http status code and other
  /// optional header values. To redirect the request to a new URL set
  /// |redirectUrl| to the new URL. |redirectUrl| can be either a relative or
  /// fully qualified URL. It is also possible to set |response| to a redirect
  /// http status code and pass the new URL via a Location header. Likewise with
  /// |redirectUrl| it is valid to set a relative or fully qualified URL as the
  /// Location header value. If an error occured while setting up the request
  /// you can call set_error() on |response| to indicate the error condition.
  ///
  void(ACF_CALLBACK* get_response_headers)(struct _acf_resource_handler_t* self,
                                           struct _acf_response_t* response,
                                           int64* response_length);

  ///
  /// Skip response data when requested by a Range header. Skip over and discard
  /// |bytes_to_skip| bytes of response data. If data is available immediately
  /// set |bytes_skipped| to the number of bytes skipped and return true (1). To
  /// read the data at a later time set |bytes_skipped| to 0, return true (1)
  /// and execute |callback| when the data is available. To indicate failure set
  /// |bytes_skipped| to < 0 (e.g. -2 for ERR_FAILED) and return false (0). This
  /// function will be called in sequence but not from a dedicated thread.
  ///
  void(ACF_CALLBACK* skip)(struct _acf_resource_handler_t* self,
                           int64 bytes_to_skip,
                           struct _acf_resource_skip_callback_t* callback);

  ///
  /// Read response data. If data is available immediately copy up to
  /// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
  /// bytes copied, and return true (1). To read the data at a later time keep a
  /// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
  /// |callback| when the data is available (|data_out| will remain valid until
  /// the callback is executed). To indicate response completion set
  /// |bytes_read| to 0 and return false (0). To indicate failure set
  /// |bytes_read| to < 0 (e.g. -2 for ERR_FAILED) and return false (0). This
  /// function will be called in sequence but not from a dedicated thread. For
  /// backwards compatibility set |bytes_read| to -1 and return false (0) and
  /// the ReadResponse function will be called.
  ///
  void(ACF_CALLBACK* read)(struct _acf_resource_handler_t* self,
                           void* data_out,
                           int bytes_to_read,
                           struct _acf_resource_read_callback_t* callback);
} acf_resource_handler_t;

///
/// Implement this structure to filter resource response content. The functions
/// of this structure will be called on the browser process IO thread.
///
typedef struct _acf_response_filter_t {
  ///
  /// Base structure.
  ///
  acf_base_ref_counted_t base;

  ///
  /// Initialize the response filter. Will only be called a single time. The
  /// filter will not be installed if this function returns false (0).
  ///
  int(ACF_CALLBACK* init_filter)(struct _acf_response_filter_t* self);

  ///
  /// Called to filter a chunk of data. Expected usage is as follows:
  ///
  ///  1. Read input data from |data_in| and set |data_in_read| to the number of
  ///     bytes that were read up to a maximum of |data_in_size|. |data_in| will
  ///     be NULL if |data_in_size| is zero.
  ///  2. Write filtered output data to |data_out| and set |data_out_written| to
  ///     the number of bytes that were written up to a maximum of
  ///     |data_out_size|. If no output data was written then all data must be
  ///     read from |data_in| (user must set |data_in_read| = |data_in_size|).
  ///  3. Return RESPONSE_FILTER_DONE if all output data was written or
  ///     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
  ///
  /// This function will be called repeatedly until the input buffer has been
  /// fully read (user sets |data_in_read| = |data_in_size|) and there is no
  /// more input data to filter (the resource response is complete). This
  /// function may then be called an additional time with an NULL input buffer
  /// if the user filled the output buffer (set |data_out_written| =
  /// |data_out_size|) and returned RESPONSE_FILTER_NEED_MORE_DATA to indicate
  /// that output data is still pending.
  ///
  /// Calls to this function will stop when one of the following conditions is
  /// met:
  ///
  ///  1. There is no more input data to filter (the resource response is
  ///     complete) and the user sets |data_out_written| = 0 or returns
  ///     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
  ///  2. The user returns RESPONSE_FILTER_ERROR to indicate an error.
  ///
  /// Do not keep a reference to the buffers passed to this function.
  ///
  acf_response_filter_status_t(ACF_CALLBACK* filter)(
      struct _acf_response_filter_t* self,
      void* data_in,
      size_t data_in_size,
      size_t* data_in_read,
      void* data_out,
      size_t data_out_size,
      size_t* data_out_written);
} acf_response_filter_t;

#ifdef __cplusplus
}
#endif

#endif  // ACF_INCLUDE_CAPI_ACF_RESOURCE_REQUEST_HANDLER_CAPI_H_
